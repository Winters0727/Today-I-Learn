### 프로세스

**프로세스**

- (비공식적으로) 실행중인 프로그램
- 프로세스는 프로그램 카운터와 관련 자원의 집합을 가진 _능동적인 존재_
- 프로세스의 상태는 프로그램 카운터와 프로세스 레지스터로 표현
- **텍스트(코드) 영역**: 실행 코드
- **데이터 영역**: 전역 변수
- **힙 영역**: 프로그램 실행 중에 동적으로 할당되는 메모리
- **스택 영역**: 함수 호출 시 임시 데이터 저장장소(매개변수, 지역변수, 복귀 주소 등)
- 함수가 호출될 때마다 **활성화 레코드(activation record)**가 스택에 push, 함수로부터 제어권이 돌아오면 스택에서 pop

**프로세스 상태**

- **새로운(new)**: 프로세스 생성
- **실행(running)**: 명령어 실행
- **대기(waiting)**: 프로세스가 어떤 이벤트(입출력 및 신호 수신)의 발생을 기대
- **준비(ready)**: 프로세스가 처리기에 할당되기까지 대기
- **종료(terminated)**: 프로세스의 실행 종료

**프로세스 제어 블록(PCB, Process Control Block)**

- **프로세스 상태**: 프로세스의 상태 정보
- **프로그램 카운터**: 프로세스가 다음에 실행할 명령어의 주소
- **CPU 레지스터들**: 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지서트 및 상태 코드 정보. 프로그램 카운터와 함께 프로세스가 다시 스케줄 될 때 실행되기 위해서 인터럽트 시에 저장해야한다.
- **CPU 스케줄링 정보**: 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함
- **메모리 관리 정보**: 운영체제에 의해 사용되는 메모리 시스템에 따라 기준 레지스터와 한계 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- **회계(accounting) 정보**: CPU 사용 시간 및 경과 시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함
- **입출력 상태 정보**: 프로세스에 할당된 입출력 장치들과 열린 파일들의 목록 등을 포함

**프로세스 스케줄링**

- **프로세스 스케줄러**: 코어에서 실행 가능한 여러 프로세스 중 하나의 프로세스를 선택
- 다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면 프로세스의 일반적인 동작을 고려해야한다.
  - **I/O 바운드 프로세스**: 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스
  - **CPU 바운드 프로세스**: 계산에 더 많은 시간을 사용하여 I/O 요청을 생성하지 않는 프로세스

**스케줄링 큐**

- 프로세스가 시스템에 들어가면 **준비 큐**(연결 리스트)에 들어가서 준비 상태가 되고 CPU 코어에서 실행되기를 기다린다. 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함된다.
- I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 **대기 큐**에 삽입된다.
- 프로세스가 CPU 코어에 할당되면 여러 이벤트 중 하나가 발생할 수 있다.
  - 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있다.
  - 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.
  - 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.

**CPU 스케줄링**

- 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 역할
- 일부 운영체제는 **스와핑**으로 알려진 중간 형태의 스케줄링을 가진다.
  - 메모리(및 CPU에 대한 능동적 경쟁)에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시키고, 나중에 프로세스를 메모리에 적재하여 중단된 위치부터 실행
  - 프로세스를 메모리에서 디스크로 보내 저장하는 것을 '스왑아웃', 디스크에 저장된 프로세스를 메모리에 적재하는 것을 '스왑인'이라 하여 이 기법을 **스와핑**이라 한다.
  - 스와핑은 일반적으로 메모리가 초과 사용되어 가용공간을 확보할 때만 필요하다.

**문맥 교환(Context Switch)**

- 인터럽트가 발생했을 때 시스템은 실행 중이던 프로세스의 문맥(Context)를 중지시키고, 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 문맥을 저장할 필요가 있다. 여기서 문맥은 프로세스의 PCB에 표현된다.
- CPU 코어가 다른 프로세스로 전환할 때, 현재 실행 중인 프로세스가 있으면 실행 중인 프로세스의 상태를 저장하고 새로운 프로세스의 보관된 상태를 복구하는 작업
- 문맥 교환 시간은 순수한 오버헤드이며, 하드웨어의 지원에 크게 좌우된다.

**프로세스 간 통신(Interprocess Communication)**

- 운영체제 내에서 실행되는 병행 프로세서들은 독립적이거나 협력적인 프로세스들일 수 있다. 프로세스가 시스템에서 실행 중인 다른 프로세스들과의 데이터 공유 여부에 따라 **독립적/협력적** 프로세스라 한다.
- 프로세스 협력을 허용하는 환경을 제공하는 데는 몇 가지 이유가 있다.
  - **정보 공유**: 여러 응용 프로그램이 동일한 정보에 관심을 가진다면 그러한 정보는 병행적으로 접근할 수 있는 환경을 제공해야 한다.
  - **계산 가속화**: 특정 태스크를 빠르게 실행시키고 싶을 때, 그 태스크를 서브 태스크로 나누어 각각의 서브 태스크들을 병렬로 실행하게 해야 한다. (복수 개의 코어 필요)
  - **모듈성**: 모듈식 형태로 시스템을 구성하기를 원할 수 있다.
- 협력적 프로세스들은 데이터를 교환할 수 있는 **프로세스 간 통신(IPC)** 기법이 필요하다.
  - 프로세스 간 통신에는 기본적으로 **공유 메모리(shared memory)**와 **메시지 전달(message passing)**의 두 가지 모델이 있다.

**공유 메모리 시스템 in IPC**

- 공유 메모리를 사용하는 프로세스 간 통신에는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다.
- 통상 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치한다. 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 한다.
- 생산자-소비자 문제의 하나의 해결책이다.

**메시지 전달 시스템 in IPC**

- 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고 그들의 동작을 동기화할 수 있도록 허용하는 기법
- 분산 환경에서 유용
- 보내기(send)와 받기(receive)
- 프로세스 간의 통신을 원하면 *통신 연결*이 설정되어야 한다.
  - 직접/간접 통신
  - 동기/비동기식 통신
  - 자동/명시적 버퍼링

**클라이언트 서버 환경에서 통신**

- **소켓(socket)**: 통신의 극점. 두 프로세스가 네트워크상에서 통신을 하기 위해 각각 소켓을 가져야한다. 각 소켓은 IP 주소와 포트 번호 두 가지를 접합하여 구별한다.
- **원격 프로시저 호출(RPC)**

### 스레드

스레드는 CPU 이용의 기본 단위로 스레드 ID, 프로그램 카운터(PC), 레지스터 집합, 스택으로 이루어진다. 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 및 운영체제 자원들을 공유한다. 다중 스레드 프로그래밍은 한 프로세스 내에 여러 스레드를 사용하여 작업을 효율적으로 처리한다.

**다중 스레드 프로그래밍의 장점**

- **응답성**: 대화형 응용을 다중 스레드화하면 응용 프로그램의 일부가 멈추거나 긴 작업을 수행하더라도 사용자에 대한 응답성을 증가시킨다.
- **자원 공유**: 프로세스는 공유 메모리와 메시지 전달 기법을 통해서만 자원을 공유할 수 있는 반면, 스레드는 그들이 속한 프로세스의 자원들과 메모리를 공유한다.
- **경제성**: 스레드는 프로세스의 자원을 공유하기 때문에 프로세스보다 생성 작업에 메모리와 자원을 덜 사용한다.
- **규모 적응성**: 다중 처리기 구조에서 병렬 작업을 수행할 수 있다.

**병렬 실행**

- **데이터 병렬 실행**: 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행
- **태스크 병렬 실행**: 데이터가 아닌 태스크(스레드)를 다수의 코어에 분배하고. 각 스레드는 고유의 연산을 실행

**다중 스레드 모델**

- **일대일 모델**, **일대다 모델**, **다대다 모델**

**스레드 라이브러리**

- **동기 스레딩**: 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신을 실행
- **비동기 스레딩**: 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 독립적으로 병행하게 실행

**암묵적 스레딩**

- 스레딩의 생성과 관리 책임을 응용 개발자로부터 컴파일러와 실행시간 라이브러리에 넘기는 전략
- **스레드 풀**: 일정한 수의 스레드들을 미리 풀로 만들어두고, 생성된 스레드들은 평소에 대기 상태에 있다가 요청을 받으면 작업을 수행한다.
  - 스레드를 생성 및 폐기하는 작업은 자원이 많이 소비되고 CPU 및 메모리의 크기는 한계가 있으므로 최대 스레드의 개수를 제한할 필요가 있다.
  - 스레드 생성 및 폐기가 없으므로 작업 속도가 빠르며, 임의로 최대 스레드의 개수를 제한할 수 있다. 또한, 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크를 실행을 다르게 할 수 있다.

### CPU 스케줄링

**CPU I/O 버스트 사이클**

- 프로세스 실행은 CPU 실행과 I/O 대기의 **사이클**로 구성된다.
- 프로세스 실행은 **CPU 버스트**로 시작되고, 뒤이어 **I/O 버스트**가 발생한다. 마지막 **CPU 버스트**는 프로세스의 종료를 의미한다.
- CPU는 유휴 상태가 될 때마다 준비 큐에 있는 프로세스들 중 하나를 선택해 실행하는데, 이는 **CPU 스케줄러**에 의해 이루어진다.

**CPU 스케줄 방법**

- CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생한다.
  - 한 프로세스가 실행 상태에서 대기 상태로 전환될 때
  - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
  - 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때
  - 프로세스가 종료될 때
- 상황 1과 4는 스케줄링 면에서 선택의 여지가 없다. 실행을 위해 반드시 선택되어야 한다.
- 상황 2와 3은 선택의 여지가 있다.

- **선점 스케줄링**: 비선점 스케줄링 외의 스케줄링
- **비선점 스케줄링**: 상황 1과 4에서만 스케줄링이 발생할 경우

**디스패처(Dispatcher)**

- CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 분배하는 모듈
  - 한 프로세스에서 다른 프로세스로 문맥을 전환
  - 사용자 모드로 전환
  - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동
- 디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는 데까지 소요하는 시간을 **디스패처 지연**이라고 한다.

**스케줄링 기준**

- **CPU 이용률**, **처리량**, **총처리 시간**, **대기 시간**, **응답 시간**
- CPU 이용률과 처리량을 최대화, 총처리 시간, 응답시간과 대기 시간은 최소화

**스케줄링 알고리즘**

- 준비 큐에 있는 어느 프로세스에 CPU 코어를 할당할 것인지를 결정
- **선입 선처리(FCFS, First Come, First Served)**: CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
  - 비선점형 알고리즘
  - **호위 효과(convoy effect)**: 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것
- **최단 작업(SJF, Shortest Job First)**: 각 프로세스에 다음 CPU 버스트 길이(프로세스 전체 길이가 아니다!)를 연관하여 가장 작은 CPU 버스트를 가진 프로세스를 CPU에 할당한다.
  - 우선순위 스케줄링의 특수 케이스
  - 선점형 / 비선점형 알고리즘
  - 선점형 SJF: 최소 잔여 시간 우선 스케줄링. 현재 실행하는 프로세스를 선점
  - 비선점형 SJF: 현재 실행하는 프로세스의 CPU 버스트를 끝내도록 허용
- **라운드 로빈(Round-Robin)**: 선입 선처리 스케줄링에 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된 알고리즘이다.
- 선점형 알고리즘
  - **시간할당량/타임 슬라이스**: 작업 단위의 작은 시간
  - 유일하게 실행 가능한 프로세스가 아니라면 연속적으로 두 번 이상 시간 할당량을 할당받지 않는다.
  - 시간 할당량 크기에 영향을 많이 받으며, 시간 할당량이 매우 크면 선입 선처리 정책과 같다.
- **우선순위 스케줄링**: 우선순위가 각 프로세스들에 연관되어 있으며, 우선순위가 가장 높은 프로세스들부터 할당 되고 동일한 우선순위를 가진 경우에는 선입 선처리 순서로 스케줄 된다.
  - 선점형 / 비선점형 알고리즘
  - 선점형: 새로 도착한 프로세스와 현재 실행 중인 프로세스의 우선순위를 비교하여 CPU 선점 여부를 결정
  - 비선점형: 새로 도착한 프로세스를 준비 큐의 머리 부분에 삽입
  - **무한 봉쇄/기아 상태**: 실행 준비는 되어있으나 우선순위가 낮은 프로세스들이 실행되지 않고 CPU를 무한히 대기시키는 상태
  - **노화(aging)**: 무한 봉쇄/기아 상태의 해결 방법. 오랫동안 시스템의 준비 큐에 대기한 프로세스들의 우선순위를 점진적으로 높이는 방식.
- **다단계 큐 스케줄링**:
