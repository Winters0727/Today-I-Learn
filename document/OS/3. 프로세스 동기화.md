### 배경

**경쟁 상태(race condition)**

- 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고. 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황
- 한순간에 하나의 프로세스만이 자료에 접근하도록 허용한 후, **동기화** 과정이 필요하다.

### 임계구역 문제

**임계구역(critical section)**

- 다른 프로세스와 공유하고 있는 자원에 접근 및 갱신하는 코드
- 한 프로세스가 임계구역에서 작업하고 있으면 다른 프로세스는 임계구역에 접근할 수 없어야 한다.

**임계구역 문제**

- 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것
- **진입 구역(entry section)**: 임계구역 진입 허가 요청 코드
- **퇴출 구역(exit section)**: 임계구역 퇴출 코드
- 그 외에는 **나머지 구역(remainder section)**

임계구역 문제에 대한 해결안은 다음의 세 가지 요구 조건을 충족해야 한다.

- **상호 배제(mutual exclusion)**: 한 프로세스가 임계구역에서 실행된다면 다른 프로세스들은 자신의 임계구역을 실행시킬 수 없다.
- **진행(progress)**: 자신의 임계구역에서 실행되는 프로세스가 없고 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면 나머지 구역에서 실행 중이지 않은 프로세스들만 다음 임계구역에 진입할 프로세스를 결정할 수 있으며, 이 선택은 무한정 연기될 수 없다.
- **한정된 대기(bounded waiting)**: 프로세스가 자신의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.

운영체제 내에서 임계구역을 다루기 위해서 선점형 커널과 비선점형 커널의 두 가지 일반적인 접근법이 사용된다.

- **선점형 커널**: 프로세스가 커널 모드에서 수행되는 동안 서점되는 것을 허용
  - 비선점형 커널에 비해 빠른 속도
  - Real time system에서 빠른 응답이 필요하기 때문에 사용
- **비선점형 커널**: 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행
  - 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로 커널 자료구조에 대한 경쟁 상태가 발생하지 않음

**피터슨 알고리즘(Peterson's Algorithm)**

- 프로세스가 2개일 때만 사용 가능
- 임계구역에 진입할 프로세스는 무엇인가? && 임계구역에 진입할 준비가 되어있는가?
- 바쁜 대기 때문에 CPU 자원을 낭비

**테스트 엔 셋(test and set)**

- 하드웨어적 해결 방법
- 임계구역에서의 프로세스 유무에 따라 Lock을 설정
- 기아 상태가 발생할 가능성이 있음

**비교와 변경(compare and swap)**

- Lock의 메모리 주소, 기댓값, 설정할 값을 받음
- 기아 상태가 발생할 가능성이 있음

**라이브니스**

- 프로세스가 실행 수명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야 하는 일련의 속성

### Mutex Locks

**Mutex Lock**

- 임계구역을 보호하고 경쟁 조건을 방지하기 위해 Lock을 부여하는 것
- 임계구역 진입 시에 Lock을 획득하고 임계구역을 빠져나올 때 Lock을 반환한다.
- 단점으로 **바쁜 대기**(busy waiting)를 해야한다.

### 세마포어(Semaphores)

**세마포어**

- 정수로 초기화를 제외하고는 단지 두 개의 표준 원자적 연산으로만 접근 가능
- 운영체제는 종종 카운팅(counting)과 이진(binary) 세마포어로 구분
  - **카운팅 세마포어**: 제한 없는 영역의 값을 가진다.
  - **이진 세마포어**: 0과 1사이의 값만을 가진다. 그러므로 mutex 락과 유사하게 동작한다.

### 고전적인 동기화 문제들

- **유한 버퍼 문제**

  - 생산자는 자원을 생산(in)하고, 소비자는 자원을 소비(out)한다.
  - in/out 값만으로는 버퍼에 있는 데이터 양을 알 수 없어 역할을 대체할 변수가 필요하다.
  - 변수는 임계구역으로 생산자와 소비자가 동시에 접근할 수 있어 경쟁 상태이 발생한다.

- **Readers-Writers 문제**

  - 데이터베이스에 접근할 때 reader와 writer가 동시에 접근하지 못하도록 배타적 접근 권한을 부여
  - reader-writer Lock
    - 읽기모드: 여러 프로세스가 동시에 획득 가능
    - 쓰기모드: 한번에 하나의 프로세스만 획득 가능

- **식사하는 철학자들 문제**
  - 5명의 철학자가 원탁에 앉아있고, 철학자들 사이에는 젓가락이 한 개씩 놓여있다.
  - 철학자가 식사하기 위해서는 젓가락이 한 쌍(두 개)가 필요하다. 한 명의 철학자가 식사하면 인접한 두 철학자는 식사할 수 없다.
  - 교착 상태 문제에 대한 해결책
    - 최대 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.
    - 한 철학자가 젓가락 한 쌍을 모두 집을 수 있을 때만 젓가락을 집도록 허용한다.
    - 비대칭 해결안을 사용한다. (홀수/짝수)
  - 기아 상태가 발생할 수 있다.

### 교착 상태(Deadlocks)

다중 프로그래밍 환경에서 여러 스레드가 한정된 자원을 사용하려고 서로 경쟁하는 과정에서 한 스레드가 자원을 요청했을 때, 그 시각에 자원을 사용할 수 없는 상황이 발생하여 대기 상태에 들어가고, 대기 상태에 들어간 스레드가 그 자원을 점유하고 있는 다른 스레드 역시 대기 상태에 들어가 그 상태를 변경시킬 수 없는 상황

스레드는 자원을 사용할 때 다음과 같은 과정을 거친다.

- **요청**: 스레드는 자원을 요청한다. 요청이 즉시 허용되지 않으면 스레드는 대기 상태에 들어간다.
- **사용**: 스레드는 자원에 대해 작업을 수행할 수 있다.
- **방출**: 사용을 끝낸 뒤에 스레드는 자원을 방출한다.

### 교착 상태 특성

**필요조건**

- **상호 배제(mutual exclusion)**: 최소 하나의 자원이 비공유 상태로 점유되어야 한다. 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
- **점유 대기(hold and await)**: 스레드는 최소 하나의 자원을 점유한 채, 다른 스레드에 의해 점유된 자원을 얻기 위해 대기 상태에 들어가야 한다.
- **비선점(no preemption)**: 자원들은 선점이 불가능하다. 자원은 강제적으로 방출될 수 없고 점유하고 있는 스레드에 의해 자발적으로만 방출될 수 있다.
- **순환 대기(circular wait)**: 대기하고 있는 스레드의 집합[T<sub>0</sub>, T<sub>1</sub>, ..., T<sub>n</sub>]에서 각 스레드는 필요한 자원을 순환 형태로 다른 스레드가 점유하고 있다. (T<sub>0</sub>은 T<sub>1</sub>이, T<sub>1</sub>은 T<sub>2</sub>가, ... T<sub>n</sub>은 T<sub>0</sub>)

### 교착 상태 처리 방법

- 문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않은 척한다.
- 시스템이 _결코_ 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.
- 시스템이 교착 상태가 되도록 허용한 다음에 복구시키는 방법이 있다.
- **예방**, **회피**, **탐지**, **회복**

**교착 상태 예방**

- 필요조건 중 적어도 하나가 성립하지 않도록 보장하는 일련의 방법
- **상호 배제**: 자원은 공유 가능하다.
- **점유 대기**: 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장한다.
  - **단점**
  - 자원이 할당되었지만 장기간 사용되지 않을 수 있기 때문에 자원 이용률이 낮을 수 있다.
  - 기아(여러 자원을 필요로 하는 스레드가 필요로 하는 자원이 다른 스레드에 할당되었을 때 무한정 대기)가 발생할 수 있다.
- **비선점**: 자원 요청 시에 경우에 따라 자원 선점을 허용한다.
- **순환 대기**: 스레드 및 프로세스는 순서를 부여받아 순서에 따라 자원을 요청한다.

**교착 상태 회피**

- 스레드가 요청한 자원에 대한 부가적이 정보를 미리 제공할 것을 요구
- 정보를 바탕으로 운영체제가 스레드의 대기 여부를 결정
- **안전 상태(safe state)**: 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을 교착 상태를 발생시키지 않고 할당해줄 수 있는 **안전 순서**의 여부를 결정하는 알고리즘
- **자원 할당 그래프 알고리즘(resource-allocation graph algorithm)**:

**교착 상태 탐지**

**교착 상태 회복**
